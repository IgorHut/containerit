---
title: "Generating Dockerfiles for reproducible research with R"
author: "Daniel NÃ¼st, Matthias Hinz"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Introduction to package \texttt{containeRit}}
  %\VignetteEncoding{UTF-8}
---

<!-- Copyright 2017 Opening Reproducible Research (http://o2r.info) -->

## 1. Introduction

Even though R is designed for open and reproducible research, users who want to share their work with others are facing unexpecting challanges: sharing the R script by itself is warant for reproducibility, as many analyses rely on external resources and software as well. An R script may produce unexpected results or errors when executed under a different version of R, dependend software or even platform. Reproduciblility is only assured by providing complete setup instructions and resources. Long-term reproducibility can be achieved by either regular maintainance of code or by providing the runtime environment in it's original state, using [virtual machines](https://en.wikipedia.org/wiki/Virtual_machine) or  [software containers](https://en.wikipedia.org/wiki/Operating-system-level_virtualization).

The intention of the R extension package `containerit` is to provide a building block to support reproducible and archivable research. Development is supported by the DFG-funded project Opening Reproducible Research ([http://o2r.info](http://o2r.info)). `containerit` relies on [Docker](http://docker.com/) and seeks automatically generate setup instructions from a given R session, script, r-markdown file or workspace directory. The resulting [`Dockerfile`](https://docs.docker.com/engine/reference/builder/) can not only be read and understood by humans, but also be interpreted by the Docker engine so that it creates a software container that contains all the R packages and their system dependencies required by an R workflow to be packaged. 

The Dockerfiles are based on [rocker](https://github.com/rocker-org/rocker) (on [Docker Hub](https://hub.docker.com/u/rocker/)). Using the stack of version-stable Rocker images, it is possible to match the container's R version with the local R installation or any R version the user requires. `containerit` requires any input to execute locally first in order to detect all dependencies from the workspace. For determining external software dependencies of attached packages, `containerit` relies on the [sysreqs database](https://sysreqs.r-hub.io/) and makes use of the corresponding web API and R package.

To build images and run containers, the package integrates with the [harbor](https://github.com/wch/harbor) package and adds a few convenience functions for interacting with Docker images and containers. For nitty gritty things like reading / loading / installing the _exact_ versions, including system dependencies, internal and external libraries etc., this project is focused on the geospatial domain.


## 2. Creating a Dockerfile

The easiest way to way to generate a Dockerfile is to run the analysis in an interactive session where `containerit` is loaded into and to call the `dockerfile()`- method with default parameters. As shown in the example below, the result can be pretty-printed and written to a file. If no file - argument is supplied to `write()`, the Dockerfile is written to the working directory as `./Dockerfile`

- The dockerfile context must always be the same as the R working directory (because file path have to be relative and would be difficult to manage otherwise)

## 2.1 Packaging an interactive session
```{r}
library("containeRit")

# do stuff, based on demo("krige")
library("gstat")
library("sp")

data(meuse)
coordinates(meuse) = ~x+y
data(meuse.grid)
gridded(meuse.grid) = ~x+y
v <- variogram(log(zinc)~1, meuse)
m <- fit.variogram(v, vgm(1, "Sph", 300, 1))
plot(v, model = m)

dockerfile_object <- dockerfile()
```

The printout shows the general structure of a Dockerfile, which follows a pre-defined order: At first, the base image and the maintainer label are defined. They are followed by instructions that install system dependencies and external software. Afterwards, the R packages themselves are installed and the working directory is set. Not included in this example are copy instructions and metadata labels, which are included after the workdir-instructions. The final line always declares a CMD instruction, which defines the default command executed when running the container. Note that the maintainer label as well as the R version of the base image are detected from the runtime environment, if not set otherwise.

```{r,results='markup'}
print(dockerfile_object)
```

```{r}
write(dockerfile_object, file = tempfile())
```


## 2.1 Packaging an external session

Packaging an interactive session has the disadvantage that unnecessary dependencies might be drawn in, for instance the package `futile.logger` is a depency of `containerit`, but it will be installed because it was loaded into the same session were the analyses was executed. It cannot be ruled out, because some of the methods in the analyses _might_ have used it as well (even unintentionally in case of generic methods). Therefore, it is safer to run the analysis in an isolated _vanilla_ session. If only few commands need to be executed, they can be passed as a list of expressions either to the `dockerfile` method or to the convenience method `clean_session()`. The latter will batch-execute the commands in a seperate instance of R and retrieves an object of class `sessionInfo`, which can be inspected and set as an input to `dockerfile()`. This is also how `dockerfile()` works internally when packaging either expressions, scripts or markdown files.

```{r}
exp <- c(expression(data(meuse, package = "sp"), 
            expression(mean(meuse$zinc))))
dockerfile_object <- dockerfile(exp)
print(dockerfile_obj)
```


## 2.2 Packaging an R script



## 2.4 Packaging an R markdown file



## 2.5 Packaging a workspace directory

cannot be ruled out because it was loaded into the same session were the analyses was 

- from the current session (from an external session)
- from a script --> use CMD_Script
- from a markdown --> use RCMD_Render
- search directory (give dir)

--print/write results

## 3. Including Resources

Analyses in R often rely on external files and resources that are located located in the workspace. When scripts or R markdown files are packaged, they are copied by default into the same location relative to the working directory. The argument `copy` influences how `dockefile()` behaves in this matter. It can either have the values `script` (default behaviour), `script_dir` (copies the complete directory in which the input file is located), or a custom list of of files and directories inside the current working directory


Examples:
dockerfile("abc", copy = "script_dir")



(Taken from the tests:)
  df <- dockerfile("simple_test_script_resources/",
                copy = "script_dir",
                cmd = CMD_Rscript("simple_test_script_resources/simple_test.R")

 print(df)
  df <- dockerfile("simple_test_script_resources/simple_test.R", 
                copy = c("simple_test_script_resources/simple_test.R",
                         "simple_test_script_resources/test_table.csv",
                         "simple_test_script_resources/test_subfolder/testresource")
  print(df)                       
                         
Including R objects works similar using the argument `save_image`. The argument can be set TRUE/FALSE so that it saves all objects of the current workspace to an .RData file, which then copied to the container's working directory and loaded on startup (calls save.image()). Alternatively, a list of object names as well as other arguments can be passed as a list, which then will be passed to the save() function.
  
  df <- dockerfile(save_image = TRUE)
   print(df)
  
   original_sessionInfo <- sessionInfo() #the object to be saved
  df <- dockerfile(save_image = list("original_sessionInfo"))
  print(df)

dockerfile()

- save workspace
- COPY input file / dir / dirs, files...


## 4. Metadata

- Maintainer Label
- [Label Schema](http://label-schema.org/) for built
- Add any label

## 5. Costumization 

Add any Instruction
User 


## 6. Challenges



## 7. Conclusions and Further Work
Match ex
Eventually it should/could be possible to create images from scratch?

## tl;dr


```{r,results='hide',echo=FALSE}
# https://stackoverflow.com/questions/7505547/detach-all-packages-while-working-in-r
clear_all <- function() {
  # objects
  rm(list = ls(all = TRUE))
  
  # packages
  .kept.packages <- c("stats","graphics","grDevices","utils","datasets",
                      "methods","base", "tools", "stringr", "stringi",
                      "containeRit", "futile.logger", "futile.namespaces", "futile.options", "lambda.r")
  .package.list <- search()[ifelse(unlist(gregexpr("package:",search()))==1,TRUE,FALSE)]
  .package.list <- setdiff(.package.list, paste("package:", .kept.packages, sep = ""))
  if (length(.package.list)>0)
    for (package in .package.list) detach(package, character.only=TRUE)
  
  # packages loaded via namespaces
  # .tounload <- setdiff(loadedNamespaces(), .kept.packages)
  # while( ! length(.tounload) == 0 ){
  #   for(i in seq_along(.tounload)){
  #     cat("unloading ", .tounload[i], "\n")
  #     suppressWarnings(tryCatch(unloadNamespace(.tounload[i]), error = function(x) return(NA)))
  #   }
  #   .nowloaded <- setdiff(loadedNamespaces(), .kept.packages)
  #   .tounload <- sample(.nowloaded); # randomimze list order
  # }
  
  cat("cleaned up!\n")
}

clear_all()
```

## Dockerfile examples

The following demos use the [rgdal](https://cran.r-project.org/web/packages/rgdal/index.html) package because it has system library dependencies, namely GDAL and PROJ.4. Code snippets are taken from the [sp gallery](http://edzer.github.io/sp/).

Here is some regular R code loading a file and plotting it.

```{r, message=FALSE}
library("rgdal")
library("maptools")

nc <- rgdal::readOGR(system.file("shapes/", package="maptools"), "sids", verbose = FALSE)
proj4string(nc) <- CRS("+proj=longlat +datum=NAD27")
plot(nc)
```

```{r,results='hide',echo=FALSE}
clear_all()
```

### Create Dockerfile from session

```{r}
class(sessionInfo())
containeRit::dockerfile(from = sessionInfo(), env = ls())
```

```{r,results='hide',echo=FALSE}
clear_all()
```

### Script

```{r}
scriptFile <- tempfile(pattern = "containeRit_", fileext = ".R")
file <- file(scriptFile)
writeLines(c('nc <- rgdal::readOGR(system.file("shapes/", package="maptools"), "sids", verbose = FALSE)',
             'proj4string(nc) <- CRS("+proj=longlat +datum=NAD27")',
             'plot(nc)'), file)
close(file)
class(file)

#containerit::dockerfile(from = file)
```

### Workspace

Go through all `.R` files in a directory and create a Dockerfile with a runtime environment which can run all of them.

```{r, }
workspace <- getwd()
class(workspace)
dir.exists(workspace)

#containerit::dockerfile(from = workspace)
```

## sessionInfo()

```{r}
sessionInfo()
```



